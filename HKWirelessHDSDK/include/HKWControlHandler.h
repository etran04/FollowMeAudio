//
//  HWControlHandler.h
//  FCPlayer
//
//  Created by Seonman Kim on 12/30/14.
//  Copyright (c) 2014 Harman International. All rights reserved.
//

#ifndef FCPlayer_HWControlHandler_h
#define FCPlayer_HWControlHandler_h

// This is saying that this configuration is for lightweight version of the SDK library
//#define HKWIRELESSHDSDK_LW
// This is set to Project setting.

#import <Foundation/Foundation.h>
#import <AVFoundation/AVFoundation.h>
#import "DeviceInfo.h"
#import "DeviceGroup.h"

#define kModelNameOmniAdapt @"Omni Adapt"
#define kModelNameOmni10 @"Omni 10"
#define kModelNameOmni20 @"Omni 20"
#define kModelNameOmniBar @"Omnibar"
#define kModelNameUnknown @"Model Unknown"

#define HKW_INIT_SUCCESS 0
#define HKW_INIT_FAILURE_LICENSE_INVALID (-1)

typedef NS_ENUM(NSInteger, HKErrorCode)
{
    ERROR_TIMEOUT,
    ERROR_DISC_TIMEOUT,
    ERROR_SYNC_TIMEOUT,
    ERROR_STREAM_TIMEOUT,
    ERROR_DATA_TIMEOUT,
    ERROR_LOST_CONNECTION,
    ERROR_INCOMPATIBLE_VERSION,
    ERROR_MEDIA_UNSUPPORTED,
    ERROR_INVALID_DESTINATION,
    ERROR_LEFT_SESSION,
    ERROR_BAD_LOGIC,
    ERROR_CONFIG_FAILURE,
    
    ERROR_UNDEFINED
} ;

typedef NS_ENUM(NSInteger, HKPlayerState)
{
    EPlayerState_Initialized,        // Initialised
    EPlayerState_Playing,        // Playing
    EPlayerState_Preparing,   // Preparing
    EPlayerState_Paused,       // Paused
    EPlayerState_Stopped         // Stopped
} ;

typedef NS_ENUM(NSInteger, HKRole)
{
    EMono = 21,             // Mono       21
    
    EStereoL = 1,           // Left sound of 2.0 channel:   1
    EStereoR = 2,           // Right sound of 2.0 channel:   2
    
    ESurroundL = EStereoL,  // 5.1 L      1
    ESurroundLS = 5,        // 5.1 Ls     5
    ESurroundR = EStereoR,  // 5.1 R      2
    ESurroundRS = 6,        // 5.1 RS     6
    ESurroundC = 3,         // 5.1 C      3
    ESurroundSUB = 4,       // 5.1 Sub    4
    
    // For FCSB
    EFCSB21SoundBar = 10,
    EFCSB21Subwoofer = 11,
    EFCSB51SoundBar = 12,
    EFCSB51Subwoofer = 13,
};

typedef NS_ENUM(NSInteger, HKWifiSingalStrength)
{
    WifiSingalStrength_None,
    WifiSingalStrength_Weak,
    WifiSingalStrength_Normal,
    WifiSingalStrength_Strong,
    WifiSingalStrength_Strongest
};

typedef NS_ENUM(NSInteger, HKDeviceStatusReason)
{
    HKDeviceStatusReasonGeneric,
    HKDeviceStatusReasonNetworkUnavailable,
    HKDeviceStatusReasonDeviceAvailable,
    HKDeviceStatusReasonDeviceUnavailable,
    HKDeviceStatusReasonDeviceError,
    HKDeviceStatusReasonSpeakerInfoUpdated,
    HKDeviceStatusReasonWifiSignalChanged,
};

@interface HKWControlHandler : NSObject

#pragma mark - Initialization

/*!
 * @brief Returns the singleton object of HWKControlHandler.
 */
+ (HKWControlHandler *)sharedInstance;


/*!
 * @brief Initializes and starts HKWirelessHD controller. This API requires a license key as string. If the input license key fails in key validation, then the API returns -1 as result. If it is successful, return 0. <p>This is a blocking call, and it will not return until the caller successfully initializes HKWireless controller. If the phone is not connected to a Wi-Fi network, or any other app on the same phone is using the HKWireless controller, it waits until the app releases the controller.<p>If you needs non-blocking behavior, you should call this API asynchronously using other thread.
 * @param licenseKey a string containing the license key
 * @param withSpeakersAdded boolean value that specifies if all the speakers available in the network will be added right after initialzation. If TRUE, then all speakers will be added to session, so you can play music right away. If FALSE, none of speakers will be added to playback session, so you need to add speakers individually to session to play music.
 * @return an integer indicating success (0 or HKW_INIT_SUCCESS) or failure (-1 or HKW_INIT_FAILURE_LICENSE_INVALID)
 */
- (NSInteger) initializeHKWirelessController:(NSString*)licenseKey withSpeakersAdded:(BOOL)withSpeakersAdded;

/*!
 * @brief Checks if HKWirelessHD controller is already initialied.
 * @return boolean value
 */
- (BOOL) isInitialized;

/*!
 * @brief Checks if HKWirelessHD controller is being initialied.
 * @return boolean value
 */

- (BOOL) initializing;


/*!
 * @brief Turns on or off printing debugging logs. All the logs generated by HKWirelessHD SDK will be shown in the log window. <p>This is a static function.
 * @param flag boolean value for on or off the debugging log.
 */
+ (void) debugPrintOn:(BOOL)flag;

#pragma mark - Refresh devices
/*!
 * @brief Refreshes the device status only one time. The device information will be refreshed and updated in DeviceInfo objects. If there is any updates on DeviceInfo objects, then DeviceStateUpdated callback defined by registerCallbackDeviceStateUpdated will be called.
 */
- (void) refreshDeviceInfoOnce;

/*!
 * @brief Starts to refresh devices every two seconds. It continues until stopRefreshDeviceInfo(). The result of refreshing device info is the same as described in refreshDeviceInfoOnce().
 */
- (void) startRefreshDeviceInfo;

/*!
 * @brief Stops refreshing devices, which was initiated by startRefreshDeviceInfo().
 */
- (void) stopRefreshDeviceInfo;

#pragma mark - Playback control

/*!
 * @brief Plays a CAF audio file. CAF includes MP3 and WAV. PlaybackStateChanged callback will return the status, EPlayerState_Play.
 * @param assetURL NSURL to the audio file.
 * @param songName the song name to be played. The soneName is used internally to save a temporary PCM file convered from the original audio file.
 * @param resumeFlag a boolean that specifies if the play resume from the point that paused or stopped in the previous playback. When starting a song from the beginning, resumeFlag must be false.
 * @return boolean value indicating success or failure
 */
- (BOOL) playCAF:(NSURL *)assetURL songName:(NSString*)songName resumeFlag:(BOOL)resumeFlag;

/*!
 * @brief Plays a CAF audio file from a certain time. CAF includes MP3 and WAV. Differently from playCAF(), this function allows to play a song from a certain time, specifyed by startTime (second). PlaybackStateChanged callback will return the status, EPlayerState_Play.
 * @param assetURL NSURL to the audio file.
 * @param songName the song name to be played. This information is used internally to save a temporary PCM file converted from the original audio file.
 * @param startTime time in second that specifies the start time.
 * @return boolean value indicating success or failure
 */
- (bool) playCAFFromCertainTime:(NSURL *)assetURL songName:(NSString*)songName startTime:(NSInteger)startTime;

/*!
 * @brief Plays a WAV file. PlaybackStateChanged callback will return the status, EPlayerState_Play.
 * @return boolean value indicating success or failure
 */
- (bool) playWAV:(NSString*)wavPath;

#ifndef HKWIRELESSHDSDK_LW
/*!
 * @brief Plays a streaming media. Note that when you stop playing the streaming music, you must use stop(), not pause().
 * @Param streamingMediaUrl a string that specifies the URL of the streaming media source. It starts with a protocol name, such as "http://" or "rtps://". Currently, http, rtps, and mms are supported. The supported file format is mp3, m4a, wav.
 * @Param completedCallback a callback that returns the result of the playback
 */
- (void)playStreamingMedia:(NSString *)streamingMediaUrl withCallback:(void (^)(bool result))completedCallback;
#endif

/*!
 * @brief Pauses the current playback. PlaybackStateChanged callback will return the status, EPlayerState_Pause.
 */
- (void) pause;

/*!
 * @brief Stops the current playback. PlaybackStateChanged callback will return the status, EPlayerState_Stop.
 */
- (void) stop;

/*!
 * @brief Inquires whether an audio file is being played or not.
 * @return boolean value indicating if the audio is being played or now.
 */
- (bool) isPlaying;

/*!
 * @brief Inquires the current state of playback.
 * @return HKPlayerState indicate the current player state.
 */
- (HKPlayerState)getPlayerState;

#pragma mark - Volume Control

/*!
 * @brief Sets a volume level to all speakers in the network. The same volume level is set to all speakers.<p>The range of volume level is 0 (min) to the maximumVolumeLevel (currently, 50) defined by getMaximumVolumeLevel.<p>setVolume is asynchronous call. So, the effect of the API call will occur after a few milliseconds. The VolumeLevelChanged callback defined by registerCallbackVolumeLevelChanged() will be called when the volume level of the specified speaker has changed.<p>If the volume is being muted, the volume becomes unmuted first, and then set the volume.
 * @param volume the volume level
 */
- (void) setVolume:(NSInteger)volume;

/*!
 * @brief Set a volume level to an individual speaker specified by deviceId.<p>The range of volume level is 0 (min) to the maximumVolumeLevel (currently, 50) defined by getMaximumVolumeLevel.<p>setVolume is asynchronous call. So, the effect of the API call will occur after a few milliseconds. The VolumeLevelChanged callback defined by registerCallbackVolumeLevelChanged() will be called when the volume level of the specified speaker has changed.<p>If the volume is being muted, the volume becomes unmuted first, and then set the volume.
 * @param deviceId the device ID of the speaker
 * @param volume the volume level
 */
- (void) setVolumeDevice:(long long)deviceId volume:(NSInteger)volume;

/*!
 * @brief Gets the average volume level for all devices.
 * @return the average volume level of all speakers.
 */
- (NSInteger) getVolume;

/*!
 * @brief Gets the volume level of the specified speaker.
 * @param deviceId the deviceId of the speaker inquired.
 * @return the device volume level
 */
- (NSInteger) getDeviceVolume:(long long)deviceId;

/*!
 * @brief Gets the maximum volume level that the system provides.
 * @return the maximum volume level
 */
- (NSInteger) getMaximumVolumeLevel;

/*!
 * @brief Mutes the current volume.
 */
- (void) mute;

/*!
 * @brief Unmute the volume. It returns the previous volume level before mute
 */
- (void) unmute;

/*!
 * @brief Check if volume is muted or not.
 * @return the Boolean value indicating if mute is on or not.
 */
- (bool) isMuted;

#pragma mark - Device Management

/*!
 * @brief Gets the number of the groups defined by the speakers.
 * @return the number of the groups
 */
- (NSInteger) getGroupCount;

/*!
 * @brief Gets the number of the devices that belongs to a group specified by the index.
 * @param groupIndex the index of the group looking for. It starts from 0 to (GroupCount-1).
 * @return the number of device
 */
- (NSInteger) getDeviceCountInGroupIndex:(NSInteger)groupIndex;

/*!
 * @brief Gets the number of all devices in the HKWirelessHD network.
 * @return the number of devices.
 */
- (NSInteger) getDeviceCount;

/*!
 * @brief Returns the DeviceInfo object (pointer) pointed by groupIndex and deviceIndex. This API is useful to find a DeviceInfo that will be shown in a TableViewCell. For example, to show a speaker information in two section TableView, the groupIndex can correspond to section number, and deviceIndex can correspond to row number.
 * @param groupIndex The index of the group where the device belongs to.
 * @param deviceIndex The index of the device in the group.
 * @return the DeviceInfo object
 */
- (DeviceInfo *) getDeviceInfoByGroupIndexAndDeviceIndex:(NSInteger) groupIndex deviceIndex:(NSInteger)deviceIndex;

/*!
 * @brief Returns the DeviceInfo object pointed by deviceIndex from the table containing all speakers. The range of deviceIndex will be 0 to (deviceCount - 1).
 * @param deviceIndex The index of the device from the table with all devices.
 * @return the DeviceInfo object
 */
- (DeviceInfo *) getDeviceInfoByIndex:(NSInteger)deviceIndex;

/*!
 * @brief Returns the object of the DeviceGroup that a device belongs to.
 * @param deviceId the ID of the device that belongs to a DeviceGroup
 * @return the DeviceGroup object
 */
- (DeviceGroup *)getDeviceGroupByDeviceId:(long long)deviceId;

/*!
 * @brief Finds a device (speaker) by device id, and return (DeviceInfo*). It is useful to retrieve DeviceInfo with a particular deviceId.
 * @param deviceId the ID of the device we are looking for.
 * @return The DeviceInfo object
 */
- (DeviceInfo *) getDeviceInfoById:(long long) deviceId;

/*!
 * @brief Checks whether the device is active (added to the current playback session) or not.
 * @param deviceId The ID of the device
 * @return boolean indicating if the device is active or not.
 */
- (BOOL) isDeviceActive:(long long)deviceId;

/*!
 * @brief Checks whether the device is available.
 * @param deviceId The ID of the device
 * @return boolean indicating if the device is available or not.
 */
- (BOOL) isDeviceAvailable:(long long)deviceId;

/*!
 * @brief Removes (ungroup) the device from the currently belonged group. It is done internally by setting the GroupName as "harman" (which is factory default device name, and implies Not-Assigned.).
 * @param deviceId The ID of the device to ungroup.
 */
- (void)removeDeviceFromGroup:(long long)deviceId;

/*!
 * @brief Adds the device to the current playback session. The added speaker will play audio. This can be done during the audio playback.
 * @param deviceId The ID of the device to add
 * @return boolean value indicating whether the addition is successful or not.
 */
- (BOOL) addDeviceToSession:(long long) deviceid;

/*!
 * @brief Removes the device from the current playback session. The removed speaker will not play audio any longer. This can be done during the audio playback.
 * @param deviceId The ID of the device to remove
 * @return boolean value indicating whether the removal is successful or not.
 */
- (BOOL) removeDeviceFromSession:(long long) deviceid;

/*!
 * @brief print the device list to the log window.
 */
- (void) printDeviceList;

/*!
 * @brief Gets the DeviceGroup by index.
 * @param groupIndex the index of the group
 * @return The object of DeviceGroup
 */
- (DeviceGroup *)getDeviceGroupByIndex:(NSInteger)groupIndex;

/*!
 * @brief Gets DeviceGroup by group ID.
 * @param groupId the ID of the group
 * @return the object of device group.
 */
- (DeviceGroup *)getDeviceGroupByGroupId:(long long)groupId;

/*!
 * @brief Gets the name of the DeviceGroup by index.
 * @param groupIndex the index of the group in the group table.
 * @return the string of group name
 */
- (NSString *)getDeviceGroupNameByIndex:(NSInteger)groupIndex;

/*!
 * @brief Gets the ID of the DeviceGroup by index.
 * @param groupIndex the index of the group in the table
 * @return the group id
 */
- (long long)getDeviceGroupIdByIndex:(NSInteger)groupIndex;

/*!
 * @brief Sets device name to a speaker. Note that you cannot set the device name by setting "deviceName" property directly. The property is read-only.
 * @param deviceId The ID of the device
 * @param name The name of the device to set
 */
- (void) setDeviceName:(long long)deviceId deviceName:(NSString *)deviceName;

/*!
 * @brief Sets device group to a speaker with Group name. Note that you cannot set the group name by setting "groupName" property directly. The property is read-only.
 * @param deviceId The id of the device
 * @param groupName The name of group
 */
- (void) setDeviceGroupName:(long long)deviceId groupName:(NSString *)groupName;

/*!
 * @brief Sets the role for the speaker. The role information is used to define which part of audio channel the speaker takes for the playback.
 * @param deviceId tThe id of the device
 * @param role the interger value indicating the role of the speaker. The possible options are listed in the HKRole enumeration type. The default value is EMono (21).
 */
- (void)setDeviceRole:(long long)deviceId role:(int)role;

/*!
 * @brief Gets the number of active devices (the devices that are added to the current playback session.)
 * @return the number of active devices
 */
- (NSInteger) getActiveDeviceCount;

/*!
 * @brief Gets the number of active groups. An active group is defined as all the devices that belongs to a group are active. If even one of the speakers in the same group is inactive, then the group is inactive.
 * @return the number of active groups
 */
- (NSInteger) getActiveGroupCount;

/*!
 * @brief Refresh the device's Wifi Signal strength value. This is asynchronous call, and the result of refreshing will come a few milliseconds later. The new WiFi signal strength value will be reported by DeviceStateUpdated callback, defined by registerCallbackDeviceStateUpdated().
 * @param deviceId The ID of the device
 */
- (void)refreshDeviceWiFiSignal:(long long)deviceId;

/*!
 * @brief Gets Wifi signal strength type by signal value
 * @param wifiSignal the wifi signal value
 */
- (HKWifiSingalStrength)getWifiSignalStrengthType:(NSInteger)wifiSignal;

/*!
 * @brief Returns a string name of player state.
 * @param playState the status of the player
 */
- (NSString*)getPlayStateString:(HKPlayerState)playState;

@end




#endif
